"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const YAML = require("yamljs");
const cheerio = require("cheerio");
const fs_1 = require("fs");
const path_1 = require("path");
const crypto_1 = require("crypto");
const jsBeautify = require("js-beautify");
const simple_git_1 = require("simple-git");
const html_minifier_1 = require("html-minifier");
const randomSeed = `${Math.random()}`.replace(/\./, "");
const banner = `# This file is generated by titan-gen, Please don't modify this file by manual.. \n`;
const generateTagInfo = function (tagName, tagAttrs) {
    const attributes = [];
    const keys = Object.keys(tagAttrs);
    const valueMap = {};
    keys.map(function (key) {
        const value = tagAttrs[key];
        if (typeof value !== "undefined") {
            const transferredValue = crypto_1.createHash("md5").update(value).digest("hex");
            valueMap[transferredValue] = value;
            attributes.push(`${key}="${randomSeed}${transferredValue}${randomSeed}"`);
        }
    });
    return {
        html: `<${tagName} ${attributes.join(" ")} >`,
        valueMap
    };
};
const langsMap = {
    "sg": ["en", "zh"],
    "my": ["en", "zh", "ms"],
    "id": ["en", "id"],
    "th": ["en", "th"],
    "pk": ["en"],
    "twc": ["ZhTw", "en"],
    "au": ["en"]
};
var SITE_COUNTRY;
(function (SITE_COUNTRY) {
    SITE_COUNTRY["sg"] = "sg";
    SITE_COUNTRY["my"] = "my";
    SITE_COUNTRY["th"] = "th";
    SITE_COUNTRY["id"] = "id";
    SITE_COUNTRY["pk"] = "pk";
    SITE_COUNTRY["twc"] = "twc";
    SITE_COUNTRY["au"] = "au";
})(SITE_COUNTRY = exports.SITE_COUNTRY || (exports.SITE_COUNTRY = {}));
const genProxyByPath = (path) => {
    if (path === "/") {
        return "/root";
    }
    path = path.replace(/\./g, ".");
    path = path.replace(/\*/g, ".*");
    const parts = path.split("/");
    if (parts[0] === "") {
        path = `/${parts.slice(1).join(".")}`;
    }
    else {
        path = `${parts.join(".")}`;
    }
    path = path.replace(/\.{2,}/, ".");
    if (/\.\w{2,5}$/.test(path) && !path.endsWith("$")) {
        path = `${path}$`;
    }
    return path;
};
function convertPages(pages) {
    return pages.reduce((pValue, cValue) => {
        if (Array.isArray(cValue.path) || (typeof cValue.path === "string" && typeof cValue.proxy === "undefined")) {
            if (Array.isArray(cValue.path)) {
                cValue.path.forEach((path) => {
                    pValue.push(Object.assign({}, cValue, { path, proxy: genProxyByPath(path) }));
                });
            }
            else {
                pValue.push(Object.assign({}, cValue, { path: cValue.path, proxy: genProxyByPath(cValue.path) }));
            }
        }
        else {
            pValue.push(cValue);
        }
        return pValue;
    }, []);
}
const loadPages = function (pagesFilePath) {
    const pages = YAML.load(pagesFilePath);
    return convertPages(pages);
};
const genHTMLFiles = function (pages, templatePath, publishPath, siteCountry, compressHtml = false, isAll = false) {
    const templateContent = fs_1.readFileSync(templatePath).toString();
    const langs = langsMap[siteCountry];
    pages.reduce((pValue, cValue) => {
        if (pValue.findIndex(({ name }) => (cValue.name === name)) === -1) {
            pValue.push(cValue);
        }
        return pValue;
    }, []).forEach(({ name, title, metas, links }) => {
        const $ = cheerio.load(templateContent, { decodeEntities: false, xmlMode: false }).root();
        let valueMaps = {};
        if (typeof title !== "undefined") {
            $.find("head title").replaceWith(`<title>${title}</title>`);
        }
        if (Array.isArray(metas)) {
            metas.forEach((metaTag) => {
                const { name, property } = metaTag;
                if (typeof name !== "undefined" || typeof property !== "undefined") {
                    const selector = `head meta${typeof name !== "undefined" ? `[name="${name}"]` : `[property="${property}"]`}`;
                    const $metaTag = $.find(selector);
                    const { html, valueMap } = generateTagInfo("meta", metaTag);
                    valueMaps = Object.assign({}, valueMaps, valueMap);
                    if ($metaTag.length > 0) {
                        $metaTag.replaceWith(html);
                    }
                    else {
                        $.find("head").append(html);
                    }
                }
            });
        }
        if (Array.isArray(links)) {
            const { browserOnly, normal } = links.reduce((pValue, cValue) => {
                const { browserOnly } = cValue, rest = __rest(cValue, ["browserOnly"]);
                if (browserOnly) {
                    pValue.browserOnly.push(rest);
                }
                else {
                    pValue.normal.push(rest);
                }
                return pValue;
            }, { browserOnly: [], normal: [] });
            normal.forEach((linkTag) => {
                const { html, valueMap } = generateTagInfo("link", linkTag);
                valueMaps = Object.assign({}, valueMaps, valueMap);
                $.find("head").append(html);
            });
            browserOnly.forEach((linkTag) => {
                $.find("head").append(`
					<script type="text/javascript">
						(function(){
							if (window.navigator.userAgent.toLowerCase().indexOf("ezbuyapp") === -1) {
								const link = document.createElement("link");
								${Object.keys(linkTag).map((key) => (`link["${key}"] = "${linkTag[key]}";`)).join("\n")}
								document.head.appendChild(link);
							}
						})();
					</script>
				`.trim());
            });
        }
        const originHtml = $.html();
        if (Array.isArray(langs) && originHtml !== null) {
            const valueKeys = Object.keys(valueMaps);
            langs.forEach((langCode) => {
                const pathname = path_1.resolve(publishPath, isAll ? `${name}.html` : `${name}_${siteCountry.toUpperCase()}_${langCode}.html`);
                let outHTML = valueKeys.reduce((pValue, cValue) => {
                    return pValue.replace(new RegExp(cValue, "mg"), valueMaps[cValue]);
                }, jsBeautify.html_beautify(originHtml.replace(new RegExp(`"${randomSeed}`, "mgi"), `'`).replace(new RegExp(`${randomSeed}"`, "mgi"), `'`)));
                if (compressHtml) {
                    outHTML = html_minifier_1.minify(outHTML, {
                        removeScriptTypeAttributes: true,
                        removeStyleLinkTypeAttributes: true,
                        minifyJS: true,
                        minifyCSS: true,
                        collapseWhitespace: true,
                        removeComments: true
                    });
                }
                outHTML = outHTML.replace(/@((?:-webkit-)?keyframes)/g, "@@$1");
                fs_1.writeFileSync(pathname, outHTML);
            });
        }
    });
};
const genPreloadYamlFile = function (pages, preloadYAMLFilePath) {
    let currentPreload = [];
    if (fs_1.existsSync(preloadYAMLFilePath)) {
        const loadedData = YAML.load(preloadYAMLFilePath);
        if (Array.isArray(loadedData.preload)) {
            currentPreload = YAML.load(preloadYAMLFilePath).preload;
        }
    }
    const preload = pages.reduce((pValue, { preloads, name }) => {
        if (Array.isArray(preloads)) {
            preloads.forEach(({ method, apiType, params }) => {
                const currentMethodIndex = currentPreload.findIndex((preload) => (preload.method === method && preload.pagePath === name));
                const newPreloadObj = {
                    apiType,
                    method,
                    params,
                    pagePath: name
                };
                if (currentMethodIndex === -1) {
                    pValue.push(newPreloadObj);
                }
                else {
                    pValue.splice(currentMethodIndex, 1, newPreloadObj);
                }
            });
        }
        return pValue;
    }, currentPreload);
    fs_1.writeFileSync(preloadYAMLFilePath, `${banner}${YAML.stringify({ preload }, 4, 2)}`.trim());
};
const genProxyYamlFile = function (pages, proxyYAMLFilePath) {
    let currentProxy = [];
    if (fs_1.existsSync(proxyYAMLFilePath)) {
        const loadedData = YAML.load(proxyYAMLFilePath);
        if (Array.isArray(loadedData)) {
            currentProxy = loadedData;
        }
    }
    const proxy = pages.reduce((pValue, { proxy, enable }) => {
        const currentProxyIndex = currentProxy.findIndex((item) => item.pathname === proxy);
        const newProxyObj = {
            pathname: proxy,
            newweb: enable
        };
        if (proxy !== undefined && enable !== undefined) {
            if (currentProxyIndex === -1) {
                pValue.push(newProxyObj);
            }
            else {
                pValue.splice(currentProxyIndex, 1, newProxyObj);
            }
        }
        return pValue;
    }, currentProxy);
    fs_1.writeFileSync(proxyYAMLFilePath, `${banner}${YAML.stringify(proxy, 4, 2)}`.trim());
};
const genTemplateYamlFile = function (pages, templateYAMLFilePath) {
    let currentPageHtml = [];
    if (fs_1.existsSync(templateYAMLFilePath)) {
        const templateYAMLData = YAML.load(templateYAMLFilePath);
        if (Array.isArray(templateYAMLData.pageHtml)) {
            currentPageHtml = templateYAMLData.pageHtml;
        }
    }
    const pageHtml = pages.reduce((pValue, { path, name }) => {
        const currentPageHtmlIndex = currentPageHtml.findIndex((item) => item.path === path);
        const newPageHtmlObj = {
            path,
            tpl: name
        };
        if (name !== "base") {
            if (currentPageHtmlIndex === -1) {
                pValue.push(newPageHtmlObj);
            }
            else {
                pValue.splice(currentPageHtmlIndex, 1, newPageHtmlObj);
            }
        }
        return pValue;
    }, currentPageHtml);
    fs_1.writeFileSync(templateYAMLFilePath, `${banner}${YAML.stringify({ default: "base", pageHtml }, 4, 2)}`.trim());
};
const genYAMLFiles = function (pages, publicPath) {
    const preloadYAMLFilePath = path_1.resolve(publicPath, "preload.yaml");
    const proxyYAMLFilePath = path_1.resolve(publicPath, "proxy.yaml");
    const templateYAMLFilePath = path_1.resolve(publicPath, "template.yaml");
    genPreloadYamlFile(pages, preloadYAMLFilePath);
    genProxyYamlFile(pages, proxyYAMLFilePath);
    genTemplateYamlFile(pages, templateYAMLFilePath);
    console.log(`gen yaml files in: ${publicPath}`);
};
const genFiles = function (pages, templatePath, publishPath, siteCountry, compressHtml = false, isAll = false) {
    pages = typeof pages === "string" ? loadPages(pages) : convertPages(pages);
    genHTMLFiles(pages, templatePath, publishPath, siteCountry, compressHtml, isAll);
    genYAMLFiles(pages, publishPath);
};
const clearAndChangeBranch = function (sitePath, isPRO) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetBranch = `master${isPRO ? "" : "-uat"}`;
        const ezbuyWebPath = path_1.resolve(sitePath, "../");
        yield simple_git_1.forceChangeBranch(ezbuyWebPath, targetBranch);
        const currentBranch = yield simple_git_1.getCurrentBranch(ezbuyWebPath);
        if (isPRO && currentBranch !== targetBranch) {
            throw new Error(`ezbuyweb can't change branch to ${targetBranch}...`);
        }
        yield simple_git_1.clearGitRepo(ezbuyWebPath);
    });
};
exports.titanGen = function ({ sitePath, templatePath, pagesFilePath, siteCountry, pages, isAll }, project, isPRO, compressHtml = false) {
    return __awaiter(this, void 0, void 0, function* () {
        yield clearAndChangeBranch(sitePath, isPRO);
        genFiles(pages !== undefined ? pages : pagesFilePath, templatePath, sitePath, siteCountry, compressHtml, isAll);
        if (!isPRO) {
            const submitResult = yield simple_git_1.submitCommit(sitePath, `publish for ${project}`);
            console.log(submitResult ? "Publish Success" : "Publish Fail");
        }
        else {
            console.log("Files gen successfully, PRO mode don't allow direct push code to online.");
        }
    });
};
exports.titanMultiSiteGen = function (genParamArr, project, isPRO, compressHtml = false) {
    return __awaiter(this, void 0, void 0, function* () {
        if (genParamArr.length > 0) {
            const { sitePath } = genParamArr[0];
            yield clearAndChangeBranch(sitePath, isPRO);
            genParamArr.forEach(({ pagesFilePath, pages, templatePath, siteCountry, sitePath, isAll }) => {
                genFiles(pages !== undefined ? pages : pagesFilePath, templatePath, sitePath, siteCountry, compressHtml, isAll);
            });
            if (!isPRO) {
                const submitResult = yield simple_git_1.submitCommit(sitePath, `publish for ${project}`);
                console.log(submitResult ? "Publish Success" : "Publish Fail");
            }
            else {
                console.log("Files gen successfully, PRO mode don't allow direct push code to online.");
            }
        }
    });
};
