import * as YAML from "yamljs";
import * as cheerio from "cheerio";
import { readFileSync, writeFileSync, existsSync } from "fs";
import { resolve } from "path";
import { createHash } from "crypto";
import * as jsBeautify from "js-beautify";
import { forceChangeBranch, getCurrentBranch, clearGitRepo, submitCommit } from "./simple-git";
import { minify } from "html-minifier";

interface IPageHTML {
	path: string;
	tpl: string;
}

export interface IPreload {
	apiType: string;
	method: string;
	params: string;
	pagePath?: string;
}

interface IProxy {
	pathname: string;
	newweb: boolean;
}

export interface IMeta {
	name?: string;
	property?: string;
	content: string;
}

export interface ILink {
	name?: string;
	rel: string;
	href: string;
	as: string;
	browserOnly?: boolean;
}

export interface Page {
	name: string;
	title?: string;
	path: string;
	proxy: string;
	enable: boolean;
	metas?: IMeta[];
	links?: ILink[];
	preloads: IPreload[];
}

interface ITitansPage {
	name: string;
	title?: string;
	path: string | string[];
	proxy: string;
	enable: boolean;
	metas?: IMeta[];
	links?: ILink[];
	preloads: IPreload[];
}

const randomSeed = `${Math.random()}`.replace(/\./, "");
const banner = `# This file is generated by titan-gen, Please don't modify this file by manual.. \n`;

const generateTagInfo = function (tagName: string, tagAttrs: any) {
	const attributes: string[] = [];
	const keys = Object.keys(tagAttrs);
	const valueMap: { [key: string]: string } = {};
	keys.map(function (key) {
		const value = (tagAttrs as any)[key] as string;
		if (typeof value !== "undefined") {
			const transferredValue = createHash("md5").update(value).digest("hex");
			valueMap[transferredValue] = value;
			attributes.push(`${key}="${randomSeed}${transferredValue}${randomSeed}"`);
		}
	});
	return {
		html: `<${tagName} ${attributes.join(" ")} >`,
		valueMap
	};
};

const langsMap = {
	"sg": ["en", "zh"],
	"my": ["en", "zh", "ms"],
	"id": ["en", "id"],
	"th": ["en", "th"],
	"pk": ["en"],
	"twc": ["ZhTw", "en"],
	"au": ["en"]
};

export enum SITE_COUNTRY {
	sg = "sg",
	my = "my",
	th = "th",
	id = "id",
	pk = "pk",
	twc = "twc",
	au = "au"
}

const genProxyByPath = (path: string) => {
	if (path === "/") {
		return "/root";
	}
	path = path.replace(/\./g, ".");
	path = path.replace(/\*/g, ".*");
	const parts = path.split("/");
	if (parts[0] === "") {
		path = `/${parts.slice(1).join(".")}`;
	} else {
		path = `${parts.join(".")}`;
	}
	path = path.replace(/\.{2,}/, ".");
	if (/\.\w{2,5}$/.test(path) && !path.endsWith("$")) {
		path = `${path}$`;
	}
	return path;
};

function convertPages(pages: ITitansPage[]) {
	return pages.reduce<Page[]>((pValue, cValue) => {
		if (Array.isArray(cValue.path) || (typeof cValue.path === "string" && typeof cValue.proxy === "undefined")) {
			if (Array.isArray(cValue.path)) {
				cValue.path.forEach((path) => {
					pValue.push({
						...cValue,
						path,
						proxy: genProxyByPath(path)
					});
				});
			} else {
				pValue.push({
					...cValue,
					path: cValue.path,
					proxy: genProxyByPath(cValue.path)
				});
			}
		} else {
			pValue.push(cValue as Page);
		}
		return pValue;
	}, []);
}

const loadPages = function (pagesFilePath: string) {
	const pages: ITitansPage[] = YAML.load(pagesFilePath);
	return convertPages(pages);
};

const genHTMLFiles = function (pages: Page[], templatePath: string, publishPath: string, siteCountry: SITE_COUNTRY, compressHtml = false, isAll = false) {
	const templateContent = readFileSync(templatePath).toString();
	const langs = (langsMap as any)[siteCountry];

	pages.reduce<Page[]>((pValue, cValue) => {
		if (pValue.findIndex(({ name }) => (cValue.name === name)) === -1) {
			pValue.push(cValue);
		}
		return pValue;
	}, []).forEach(({ name, title, metas, links }) => {
		const $ = cheerio.load(templateContent, { decodeEntities: false, xmlMode: false }).root();
		let valueMaps: { [key: string]: string } = {};

		if (typeof title !== "undefined") {
			$.find("head title").replaceWith(`<title>${title}</title>`);
		}
		if (Array.isArray(metas)) {
			metas.forEach((metaTag) => {
				const { name, property } = metaTag;

				if (typeof name !== "undefined" || typeof property !== "undefined") {
					const selector = `head meta${typeof name !== "undefined" ? `[name="${name}"]` : `[property="${property}"]`}`;
					const $metaTag = $.find(selector);
					const { html, valueMap } = generateTagInfo("meta", metaTag);

					valueMaps = { ...valueMaps, ...valueMap };

					if ($metaTag.length > 0) {
						$metaTag.replaceWith(html);
					} else {
						$.find("head").append(html);
					}
				}
			});
		}
		if (Array.isArray(links)) {
			const { browserOnly, normal } = links.reduce<{ browserOnly: ILink[], normal: ILink[] }>((pValue, cValue) => {
				const { browserOnly, ...rest } = cValue;
				if (browserOnly) {
					pValue.browserOnly.push(rest);
				} else {
					pValue.normal.push(rest);
				}
				return pValue;
			}, { browserOnly: [], normal: [] });
			normal.forEach((linkTag) => {
				const { html, valueMap } = generateTagInfo("link", linkTag);
				valueMaps = { ...valueMaps, ...valueMap };
				$.find("head").append(html);
			});
			browserOnly.forEach((linkTag) => {
				$.find("head").append(`
					<script type="text/javascript">
						(function(){
							if (window.navigator.userAgent.toLowerCase().indexOf("ezbuyapp") === -1) {
								const link = document.createElement("link");
								${
					Object.keys(linkTag).map((key) => (`link["${key}"] = "${(linkTag as any)[key]}";`)).join("\n")
					}
								document.head.appendChild(link);
							}
						})();
					</script>
				`.trim());
			});
		}
		const originHtml = $.html();
		if (Array.isArray(langs) && originHtml !== null) {
			const valueKeys = Object.keys(valueMaps);

			langs.forEach((langCode) => {
				const pathname = resolve(
					publishPath,
					isAll ? `${name}.html` : `${name}_${siteCountry.toUpperCase()}_${langCode}.html`);
				let outHTML = valueKeys.reduce((pValue, cValue) => {
					return pValue.replace(new RegExp(cValue, "mg"), valueMaps[cValue]);
				}, jsBeautify.html_beautify(originHtml.replace(new RegExp(`"${randomSeed}`, "mgi"), `'`).replace(new RegExp(`${randomSeed}"`, "mgi"), `'`)));
				if (compressHtml) {
					outHTML = minify(outHTML, {
						removeScriptTypeAttributes: true,
						removeStyleLinkTypeAttributes: true,
						minifyJS: true,
						minifyCSS: true,
						collapseWhitespace: true,
						removeComments: true
					});
				}
				outHTML = outHTML.replace(/@((?:-webkit-)?keyframes)/g, "@@$1");
				writeFileSync(pathname, outHTML);
			});
		}

	});
};

const genPreloadYamlFile = function (pages: Page[], preloadYAMLFilePath: string) {
	let currentPreload: IPreload[] = [];

	if (existsSync(preloadYAMLFilePath)) {
		const loadedData = YAML.load(preloadYAMLFilePath);
		if (Array.isArray(loadedData.preload)) {
			currentPreload = YAML.load(preloadYAMLFilePath).preload;
		}
	}

	const preload = pages.reduce<IPreload[]>((pValue, { preloads, name }) => {
		if (Array.isArray(preloads)) {
			preloads.forEach(({ method, apiType, params }) => {
				const currentMethodIndex = currentPreload.findIndex((preload) => (preload.method === method && preload.pagePath === name));
				const newPreloadObj = {
					apiType,
					method,
					params,
					pagePath: name
				};
				if (currentMethodIndex === -1) {
					pValue.push(newPreloadObj);
				} else {
					pValue.splice(currentMethodIndex, 1, newPreloadObj);
				}
			});
		}
		return pValue;
	}, currentPreload);

	writeFileSync(preloadYAMLFilePath, `${banner}${YAML.stringify({ preload }, 4, 2)}`.trim());
};

const genProxyYamlFile = function (pages: Page[], proxyYAMLFilePath: string) {
	let currentProxy: IProxy[] = [];

	if (existsSync(proxyYAMLFilePath)) {
		const loadedData = YAML.load(proxyYAMLFilePath);
		if (Array.isArray(loadedData)) {
			currentProxy = loadedData;
		}
	}

	const proxy = pages.reduce((pValue, { proxy, enable }) => {
		const currentProxyIndex = currentProxy.findIndex((item) => item.pathname === proxy);
		const newProxyObj = {
			pathname: proxy,
			newweb: enable
		};
		if (proxy !== undefined && enable !== undefined) {
			if (currentProxyIndex === -1) {
				pValue.push(newProxyObj);
			} else {
				pValue.splice(currentProxyIndex, 1, newProxyObj);
			}
		}
		return pValue;
	}, currentProxy);

	writeFileSync(proxyYAMLFilePath, `${banner}${YAML.stringify(proxy, 4, 2)}`.trim());
};

const genTemplateYamlFile = function (pages: Page[], templateYAMLFilePath: string) {
	let currentPageHtml: IPageHTML[] = [];

	if (existsSync(templateYAMLFilePath)) {
		const templateYAMLData = YAML.load(templateYAMLFilePath);
		if (Array.isArray(templateYAMLData.pageHtml)) {
			currentPageHtml = templateYAMLData.pageHtml;
		}
	}

	const pageHtml = pages.reduce((pValue, { path, name }) => {
		const currentPageHtmlIndex = currentPageHtml.findIndex((item) => item.path === path);
		const newPageHtmlObj = {
			path,
			tpl: name
		};
		if (name !== "base") {
			if (currentPageHtmlIndex === -1) {
				pValue.push(newPageHtmlObj);
			} else {
				pValue.splice(currentPageHtmlIndex, 1, newPageHtmlObj);
			}
		}
		return pValue;
	}, currentPageHtml);

	writeFileSync(templateYAMLFilePath, `${banner}${YAML.stringify({ default: "base", pageHtml }, 4, 2)}`.trim());
};

const genYAMLFiles = function (pages: Page[], publicPath: string) {
	const preloadYAMLFilePath = resolve(publicPath, "preload.yaml");
	const proxyYAMLFilePath = resolve(publicPath, "proxy.yaml");
	const templateYAMLFilePath = resolve(publicPath, "template.yaml");

	genPreloadYamlFile(pages, preloadYAMLFilePath);
	genProxyYamlFile(pages, proxyYAMLFilePath);
	genTemplateYamlFile(pages, templateYAMLFilePath);
	console.log(`gen yaml files in: ${publicPath}`);
};


const genFiles = function (pages: string | Page[], templatePath: string, publishPath: string, siteCountry: SITE_COUNTRY, compressHtml = false, isAll = false) {
	pages = typeof pages === "string" ? loadPages(pages) : convertPages(pages);
	genHTMLFiles(pages, templatePath, publishPath, siteCountry, compressHtml, isAll);
	genYAMLFiles(pages, publishPath);
};

const clearAndChangeBranch = async function (sitePath: string, isPRO: boolean) {
	const targetBranch = `master${isPRO ? "" : "-uat"}`;
	const ezbuyWebPath = resolve(sitePath, "../");
	await forceChangeBranch(ezbuyWebPath, targetBranch);
	const currentBranch = await getCurrentBranch(ezbuyWebPath);
	if (isPRO && currentBranch !== targetBranch) {
		throw new Error(`ezbuyweb can't change branch to ${targetBranch}...`);
	}
	await clearGitRepo(ezbuyWebPath);
};

export interface IGenParams {
	pagesFilePath?: string;
	pages: string | Page[];
	templatePath: string;
	sitePath: string;
	siteCountry: SITE_COUNTRY;
	isAll?: boolean;
}

export const titanGen = async function ({ sitePath, templatePath, pagesFilePath, siteCountry, pages, isAll }: IGenParams, project: string, isPRO: boolean, compressHtml = false) {
	await clearAndChangeBranch(sitePath, isPRO);
	genFiles(pages !== undefined ? pages : (pagesFilePath as string), templatePath, sitePath, siteCountry, compressHtml, isAll);
	if (!isPRO) {
		const submitResult = await submitCommit(sitePath, `publish for ${project}`);
		console.log(submitResult ? "Publish Success" : "Publish Fail");
	} else {
		console.log("Files gen successfully, PRO mode don't allow direct push code to online.");
	}
};


export const titanMultiSiteGen = async function (genParamArr: IGenParams[], project: string, isPRO: boolean, compressHtml = false) {
	if (genParamArr.length > 0) {
		const { sitePath } = genParamArr[0];
		await clearAndChangeBranch(sitePath, isPRO);
		genParamArr.forEach(({ pagesFilePath, pages, templatePath, siteCountry, sitePath, isAll }) => {
			genFiles(pages !== undefined ? pages : (pagesFilePath as string), templatePath, sitePath, siteCountry, compressHtml, isAll);
		});
		if (!isPRO) {
			const submitResult = await submitCommit(sitePath, `publish for ${project}`);
			console.log(submitResult ? "Publish Success" : "Publish Fail");
		} else {
			console.log("Files gen successfully, PRO mode don't allow direct push code to online.");
		}
	}
};